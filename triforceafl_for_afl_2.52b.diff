diff --git a/Makefile b/Makefile
index 0b2c92b..54fe545 100644
--- a/Makefile
+++ b/Makefile
@@ -44,7 +44,10 @@ endif
 
 COMM_HDR    = alloc-inl.h config.h debug.h types.h
 
-all: test_x86 $(PROGS) afl-as test_build all_done
+all: test_x86 $(PROGS) afl-as test_build all_done #afl-qemu-system-trace afl-qemu-trace 
+# The two commented entries in the line above are part of the triforceAFL patchset,
+# but not required for the FIRMAFL reproducability study.
+# All we need is an updated afl-fuzz, the qemu variants are provided by FirmAFL
 
 ifndef AFL_NO_X86
 
@@ -89,8 +92,8 @@ ifndef AFL_NO_X86
 test_build: afl-gcc afl-as afl-showmap
 	@echo "[*] Testing the CC wrapper and instrumentation output..."
 	unset AFL_USE_ASAN AFL_USE_MSAN; AFL_QUIET=1 AFL_INST_RATIO=100 AFL_PATH=. ./$(TEST_CC) $(CFLAGS) test-instr.c -o test-instr $(LDFLAGS)
-	echo 0 | ./afl-showmap -m none -q -o .test-instr0 ./test-instr
-	echo 1 | ./afl-showmap -m none -q -o .test-instr1 ./test-instr
+	echo 0 | ./afl-showmap -m none -q -o .test-instr0 -- ./test-instr
+	echo 1 | ./afl-showmap -m none -q -o .test-instr1 -- ./test-instr
 	@rm -f test-instr
 	@cmp -s .test-instr0 .test-instr1; DR="$$?"; rm -f .test-instr0 .test-instr1; if [ "$$DR" = "0" ]; then echo; echo "Oops, the instrumentation does not seem to be behaving correctly!"; echo; echo "Please ping <lcamtuf@google.com> to troubleshoot the issue."; echo; exit 1; fi
 	@echo "[+] All right, the instrumentation seems to be working!"
@@ -108,6 +111,9 @@ all_done: test_build
 	@if [ "`uname`" = "Darwin" ]; then printf "\nWARNING: Fuzzing on MacOS X is slow because of the unusually high overhead of\nfork() on this OS. Consider using Linux or *BSD. You can also use VirtualBox\n(virtualbox.org) to put AFL inside a Linux or *BSD VM.\n\n"; fi
 	@! tty <&1 >/dev/null || printf "\033[0;30mNOTE: If you can read this, your terminal probably uses white background.\nThis will make the UI hard to read. See docs/status_screen.txt for advice.\033[0m\n" 2>/dev/null
 
+afl-qemu-system-trace afl-qemu-trace :
+	cd qemu_mode && ./build_qemu_support.sh
+
 .NOTPARALLEL: clean
 
 clean:
diff --git a/afl-analyze.c b/afl-analyze.c
index 813e79b..dfd5654 100644
--- a/afl-analyze.c
+++ b/afl-analyze.c
@@ -877,7 +877,7 @@ static void find_binary(u8* fname) {
 
 /* Fix up argv for QEMU. */
 
-static char** get_qemu_argv(u8* own_loc, char** argv, int argc) {
+static char** get_qemu_argv(int qemu_mode, u8* own_loc, char** argv, int argc) {
 
   char** new_argv = ck_alloc(sizeof(char*) * (argc + 4));
   u8 *tmp, *cp, *rsl, *own_copy;
@@ -886,18 +886,24 @@ static char** get_qemu_argv(u8* own_loc, char** argv, int argc) {
 
   setenv("QEMU_LOG", "nochain", 1);
 
-  memcpy(new_argv + 3, argv + 1, sizeof(char*) * argc);
-
+  if(qemu_mode == 1) {
+    memcpy(new_argv + 3, argv + 1, sizeof(char*) * argc);
+ 
+    new_argv[2] = target_path;
+    new_argv[1] = "--";
+  } else {
+    memcpy(new_argv + 1, argv + 1, sizeof(char*) * argc);
+  }
+ 
   /* Now we need to actually find qemu for argv[0]. */
-
-  new_argv[2] = target_path;
-  new_argv[1] = "--";
-
   tmp = getenv("AFL_PATH");
 
   if (tmp) {
 
-    cp = alloc_printf("%s/afl-qemu-trace", tmp);
+    if(qemu_mode == 1)
+      cp = alloc_printf("%s/afl-qemu-trace", tmp);
+    else
+      cp = alloc_printf("%s/afl-qemu-system-trace", tmp);
 
     if (access(cp, X_OK))
       FATAL("Unable to find '%s'", tmp);
@@ -914,7 +920,10 @@ static char** get_qemu_argv(u8* own_loc, char** argv, int argc) {
 
     *rsl = 0;
 
-    cp = alloc_printf("%s/afl-qemu-trace", own_copy);
+    if(qemu_mode == 1)
+      cp = alloc_printf("%s/afl-qemu-trace", own_copy);
+    else
+      cp = alloc_printf("%s/afl-qemu-system-trace", own_copy);
     ck_free(own_copy);
 
     if (!access(cp, X_OK)) {
@@ -926,12 +935,19 @@ static char** get_qemu_argv(u8* own_loc, char** argv, int argc) {
 
   } else ck_free(own_copy);
 
-  if (!access(BIN_PATH "/afl-qemu-trace", X_OK)) {
+  if (qemu_mode == 1 && !access(BIN_PATH "/afl-qemu-trace", X_OK)) {
+
 
     target_path = new_argv[0] = BIN_PATH "/afl-qemu-trace";
     return new_argv;
 
   }
+  if (qemu_mode > 1 && !access(BIN_PATH "/afl-qemu-system-trace", X_OK)) {
+
+    target_path = new_argv[0] = BIN_PATH "/afl-qemu-system-trace";
+    return new_argv;
+  }
+
 
   FATAL("Unable to find 'afl-qemu-trace'.");
 
@@ -1024,10 +1040,10 @@ int main(int argc, char** argv) {
 
       case 'Q':
 
-        if (qemu_mode) FATAL("Multiple -Q options not supported");
+        //if (qemu_mode) FATAL("Multiple -Q options not supported");
         if (!mem_limit_given) mem_limit = MEM_LIMIT_QEMU;
 
-        qemu_mode = 1;
+        qemu_mode += 1;
         break;
 
       default:
@@ -1049,7 +1065,7 @@ int main(int argc, char** argv) {
   detect_file_args(argv + optind);
 
   if (qemu_mode)
-    use_argv = get_qemu_argv(argv[0], argv + optind, argc - optind);
+    use_argv = get_qemu_argv(qemu_mode, argv[0], argv + optind, argc - optind);
   else
     use_argv = argv + optind;
 
diff --git a/afl-cmin b/afl-cmin
index bc3494e..8fa8f28 100755
--- a/afl-cmin
+++ b/afl-cmin
@@ -79,9 +79,7 @@ while getopts "+i:o:f:m:t:eQC" opt; do
          export AFL_CMIN_CRASHES_ONLY=1
          ;;
     "Q")
-         EXTRA_PAR="$EXTRA_PAR -Q"
-         test "$MEM_LIMIT_GIVEN" = "" && MEM_LIMIT=250
-         QEMU_MODE=1
+         QEMU_MODE="${QEMU_MODE}Q"
          ;;
     "?")
          exit 1
@@ -91,6 +89,11 @@ while getopts "+i:o:f:m:t:eQC" opt; do
 
 done
 
+if [ ! -z $QEMU_MODE ] ; then
+  # XXX set MEM_LIMIT?
+  EXTRA_PAR="$EXTRA_PAR -$QEMU_MODE"
+fi
+
 shift $((OPTIND-1))
 
 TARGET_BIN="$1"
@@ -155,13 +158,16 @@ fi
 
 TRACE_DIR="$OUT_DIR/.traces"
 
-if [ "$STDIN_FILE" = "" ]; then
-
-  if echo "$*" | grep -qF '@@'; then
-    STDIN_FILE="$TRACE_DIR/.cur_input"
-  fi
+# XXX we're using @@ in the afl-fuzz sense in afl-showmap now.
+# so get rid of this stdin stuff, which we dont support anymore. -TimN
 
-fi
+#if [ "$STDIN_FILE" = "" ]; then
+#
+#  if echo "$*" | grep -qF '@@'; then
+#    STDIN_FILE="$TRACE_DIR/.cur_input"
+#  fi
+#
+#fi
 
 # Check for obvious errors.
 
@@ -270,32 +276,35 @@ fi
 # Make sure that we can actually get anything out of afl-showmap before we
 # waste too much time.
 
-echo "[*] Testing the target binary..."
-
-if [ "$STDIN_FILE" = "" ]; then
-
-  AFL_CMIN_ALLOW_ANY=1 "$SHOWMAP" -m "$MEM_LIMIT" -t "$TIMEOUT" -o "$TRACE_DIR/.run_test" -Z $EXTRA_PAR -- "$@" <"$IN_DIR/$FIRST_FILE"
-
-else
-
-  cp "$IN_DIR/$FIRST_FILE" "$STDIN_FILE"
-  AFL_CMIN_ALLOW_ANY=1 "$SHOWMAP" -m "$MEM_LIMIT" -t "$TIMEOUT" -o "$TRACE_DIR/.run_test" -Z $EXTRA_PAR -A "$STDIN_FILE" -- "$@" </dev/null
-
-fi
-
-FIRST_COUNT=$((`grep -c . "$TRACE_DIR/.run_test"`))
-
-if [ "$FIRST_COUNT" -gt "0" ]; then
-
-  echo "[+] OK, $FIRST_COUNT tuples recorded."
-
-else
-
-  echo "[-] Error: no instrumentation output detected (perhaps crash or timeout)." 1>&2
-  test "$AFL_KEEP_TRACES" = "" && rm -rf "$TRACE_DIR"
-  exit 1
+# XXX removed this for now -- we cant afford another showmap startup
+# when showmap might take several minutes to launch forkserver -TimN
 
-fi
+#echo "[*] Testing the target binary..."
+#
+#if [ "$STDIN_FILE" = "" ]; then
+#
+#  AFL_CMIN_ALLOW_ANY=1 "$SHOWMAP" -m "$MEM_LIMIT" -t "$TIMEOUT" -o "$TRACE_DIR/.run_test" -Z $EXTRA_PAR -- "$@" <"$IN_DIR/$FIRST_FILE"
+#
+#else
+#
+#  cp "$IN_DIR/$FIRST_FILE" "$STDIN_FILE"
+#  AFL_CMIN_ALLOW_ANY=1 "$SHOWMAP" -m "$MEM_LIMIT" -t "$TIMEOUT" -o "$TRACE_DIR/.run_test" -Z $EXTRA_PAR -A "$STDIN_FILE" -- "$@" </dev/null
+#
+#fi
+#
+#FIRST_COUNT=$((`grep -c . "$TRACE_DIR/.run_test"`))
+#
+#if [ "$FIRST_COUNT" -gt "0" ]; then
+#
+#  echo "[+] OK, $FIRST_COUNT tuples recorded."
+#
+#else
+#
+#  echo "[-] Error: no instrumentation output detected (perhaps crash or timeout)." 1>&2
+#  test "$AFL_KEEP_TRACES" = "" && rm -rf "$TRACE_DIR"
+#  exit 1
+#
+#fi
 
 # Let's roll!
 
@@ -311,28 +320,13 @@ echo "[*] Obtaining traces for input files in '$IN_DIR'..."
 
   if [ "$STDIN_FILE" = "" ]; then
 
-    while read -r fn; do
-
-      CUR=$((CUR+1))
-      printf "\\r    Processing file $CUR/$IN_COUNT... "
-
-      "$SHOWMAP" -m "$MEM_LIMIT" -t "$TIMEOUT" -o "$TRACE_DIR/$fn" -Z $EXTRA_PAR -- "$@" <"$IN_DIR/$fn"
-
-    done < <(ls "$IN_DIR")
+    "$SHOWMAP" -m "$MEM_LIMIT" -t "$TIMEOUT" -o "$TRACE_DIR" -Z $EXTRA_PAR "$IN_DIR"/* -- "$@" 
 
   else
 
-    while read -r fn; do
-
-      CUR=$((CUR+1))
-      printf "\\r    Processing file $CUR/$IN_COUNT... "
-
-      cp "$IN_DIR/$fn" "$STDIN_FILE"
-
-      "$SHOWMAP" -m "$MEM_LIMIT" -t "$TIMEOUT" -o "$TRACE_DIR/$fn" -Z $EXTRA_PAR -A "$STDIN_FILE" -- "$@" </dev/null
-
-    done < <(ls "$IN_DIR")
-
+    cp "$IN_DIR/$fn" "$STDIN_FILE"
+ 
+    "$SHOWMAP" -m "$MEM_LIMIT" -t "$TIMEOUT" -o "$TRACE_DIR" -Z $EXTRA_PAR -A "$STDIN_FILE" "$IN_DIR"/* -- "$@" </dev/null
 
   fi
 
diff --git a/afl-fuzz.c b/afl-fuzz.c
index 01b4afe..b26fa7d 100644
--- a/afl-fuzz.c
+++ b/afl-fuzz.c
@@ -1998,7 +1998,7 @@ EXP_ST void init_forkserver(char** argv) {
     if (!getrlimit(RLIMIT_NOFILE, &r) && r.rlim_cur < FORKSRV_FD + 2) {
 
       r.rlim_cur = FORKSRV_FD + 2;
-      setrlimit(RLIMIT_NOFILE, &r); /* Ignore errors */
+      //XXX setrlimit(RLIMIT_NOFILE, &r); /* Ignore errors */
 
     }
 
@@ -2008,7 +2008,7 @@ EXP_ST void init_forkserver(char** argv) {
 
 #ifdef RLIMIT_AS
 
-      setrlimit(RLIMIT_AS, &r); /* Ignore errors */
+      //XXX setrlimit(RLIMIT_AS, &r); /* Ignore errors */
 
 #else
 
@@ -2452,6 +2452,11 @@ static u8 run_target(char** argv, u32 timeout) {
     kill_signal = 0;
     return FAULT_CRASH;
   }
+   
+  /* treat all non-zero return values from qemu system test as a crash */
+  if(qemu_mode > 1 && WEXITSTATUS(status) != 0) {
+    return FAULT_CRASH;
+  }
 
   if ((dumb_mode == 1 || no_forkserver) && tb4 == EXEC_FAIL_SIG)
     return FAULT_ERROR;
@@ -6855,7 +6860,7 @@ EXP_ST void check_binary(u8* fname) {
 
   }
 
-  if (getenv("AFL_SKIP_BIN_CHECK")) return;
+  if (qemu_mode > 1 || getenv("AFL_SKIP_BIN_CHECK")) return;
 
   /* Check for blatant user errors. */
 
@@ -7600,7 +7605,7 @@ EXP_ST void setup_signal_handlers(void) {
 
 /* Rewrite argv for QEMU. */
 
-static char** get_qemu_argv(u8* own_loc, char** argv, int argc) {
+static char** get_qemu_argv(int qemu_mode, u8* own_loc, char** argv, int argc) {
 
   char** new_argv = ck_alloc(sizeof(char*) * (argc + 4));
   u8 *tmp, *cp, *rsl, *own_copy;
@@ -7609,10 +7614,14 @@ static char** get_qemu_argv(u8* own_loc, char** argv, int argc) {
 
   setenv("QEMU_LOG", "nochain", 1);
 
-  memcpy(new_argv + 3, argv + 1, sizeof(char*) * argc);
+  if(qemu_mode == 1) {
+    memcpy(new_argv + 3, argv + 1, sizeof(char*) * argc);
+    new_argv[2] = target_path;
+    new_argv[1] = "--";
+  } else {
+    memcpy(new_argv + 1, argv + 1, sizeof(char*) * argc);
+  }
 
-  new_argv[2] = target_path;
-  new_argv[1] = "--";
 
   /* Now we need to actually find the QEMU binary to put in argv[0]. */
 
@@ -7620,7 +7629,10 @@ static char** get_qemu_argv(u8* own_loc, char** argv, int argc) {
 
   if (tmp) {
 
-    cp = alloc_printf("%s/afl-qemu-trace", tmp);
+    if(qemu_mode == 1)
+      cp = alloc_printf("%s/afl-qemu-trace", tmp);
+    else
+      cp = alloc_printf("%s/%s", tmp, argv[0]);
 
     if (access(cp, X_OK))
       FATAL("Unable to find '%s'", tmp);
@@ -7637,7 +7649,10 @@ static char** get_qemu_argv(u8* own_loc, char** argv, int argc) {
 
     *rsl = 0;
 
-    cp = alloc_printf("%s/afl-qemu-trace", own_copy);
+    if(qemu_mode == 1)
+      cp = alloc_printf("%s/afl-qemu-trace", own_copy);
+    else
+      cp = alloc_printf("%s/%s", own_copy, argv[0]);
     ck_free(own_copy);
 
     if (!access(cp, X_OK)) {
@@ -7649,11 +7664,18 @@ static char** get_qemu_argv(u8* own_loc, char** argv, int argc) {
 
   } else ck_free(own_copy);
 
-  if (!access(BIN_PATH "/afl-qemu-trace", X_OK)) {
+  if (qemu_mode == 1 && !access(BIN_PATH "/afl-qemu-trace", X_OK)) {
 
     target_path = new_argv[0] = ck_strdup(BIN_PATH "/afl-qemu-trace");
     return new_argv;
 
+  }
+  cp = alloc_printf("%s/%s", BIN_PATH, argv[0]);
+  if (qemu_mode > 1 && !access(cp, X_OK)) {
+
+    target_path = new_argv[0] = cp;
+    return new_argv;
+
   }
 
   SAYF("\n" cLRD "[-] " cRST
@@ -7884,8 +7906,8 @@ int main(int argc, char** argv) {
 
       case 'Q': /* QEMU mode */
 
-        if (qemu_mode) FATAL("Multiple -Q options not supported");
-        qemu_mode = 1;
+        //if (qemu_mode) FATAL("Multiple -Q options not supported");
+        qemu_mode += 1;
 
         if (!mem_limit_given) mem_limit = MEM_LIMIT_QEMU;
 
@@ -7974,7 +7996,7 @@ int main(int argc, char** argv) {
   start_time = get_cur_time();
 
   if (qemu_mode)
-    use_argv = get_qemu_argv(argv[0], argv + optind, argc - optind);
+    use_argv = get_qemu_argv(qemu_mode, argv[0], argv + optind, argc - optind);
   else
     use_argv = argv + optind;
 
diff --git a/afl-showmap.c b/afl-showmap.c
index df3f7cd..f2c5395 100644
--- a/afl-showmap.c
+++ b/afl-showmap.c
@@ -38,6 +38,7 @@
 #include <signal.h>
 #include <dirent.h>
 #include <fcntl.h>
+#include <libgen.h>
 
 #include <sys/wait.h>
 #include <sys/time.h>
@@ -46,7 +47,11 @@
 #include <sys/types.h>
 #include <sys/resource.h>
 
-static s32 child_pid;                 /* PID of the tested program         */
+static s32 forksrv_pid,               /* PID of the fork server           */
+           child_pid;                 /* PID of the tested program         */
+
+static s32 fsrv_ctl_fd,               /* Fork server control pipe (write) */
+           fsrv_st_fd;                /* Fork server status pipe (read)   */
 
 static u8* trace_bits;                /* SHM with instrumentation bitmap   */
 
@@ -231,29 +236,41 @@ static u32 write_results(void) {
 
 static void handle_timeout(int sig) {
 
-  child_timed_out = 1;
-  if (child_pid > 0) kill(child_pid, SIGKILL);
+  if (child_pid > 0) {
 
-}
+    child_timed_out = 1;
+    kill(child_pid, SIGKILL);
 
+  } else if (child_pid == -1 && forksrv_pid > 0) {
 
-/* Execute target application. */
+    child_timed_out = 1;
+    kill(forksrv_pid, SIGKILL);
 
-static void run_target(char** argv) {
+  }
+
+}
 
+
+/* start the app and it's forkserver */
+static void init_forkserver(char **argv) {
   static struct itimerval it;
+  int st_pipe[2], ctl_pipe[2];
   int status = 0;
+  s32 rlen;
+
+  if (!quiet_mode)
+    SAYF("Spinning up the fork server...\n");
+  if (pipe(st_pipe) || pipe(ctl_pipe)) PFATAL("pipe() failed");
 
   if (!quiet_mode)
     SAYF("-- Program output begins --\n" cRST);
 
-  MEM_BARRIER();
 
-  child_pid = fork();
+  forksrv_pid = fork();
 
-  if (child_pid < 0) PFATAL("fork() failed");
+  if (forksrv_pid < 0) PFATAL("fork() failed");
 
-  if (!child_pid) {
+  if (!forksrv_pid) {
 
     struct rlimit r;
 
@@ -291,6 +308,16 @@ static void run_target(char** argv) {
 
     setrlimit(RLIMIT_CORE, &r); /* Ignore errors */
 
+    /* Set up control and status pipes, close the unneeded original fds. */
+
+    if (dup2(ctl_pipe[0], FORKSRV_FD) < 0) PFATAL("dup2() failed");
+    if (dup2(st_pipe[1], FORKSRV_FD + 1) < 0) PFATAL("dup2() failed");
+
+    close(ctl_pipe[0]);
+    close(ctl_pipe[1]);
+    close(st_pipe[0]);
+    close(st_pipe[1]);
+
     if (!getenv("LD_BIND_LAZY")) setenv("LD_BIND_NOW", "1", 0);
 
     setsid();
@@ -302,6 +329,105 @@ static void run_target(char** argv) {
 
   }
 
+  /* Close the unneeded endpoints. */
+
+  close(ctl_pipe[0]);
+  close(st_pipe[1]);
+
+  fsrv_ctl_fd = ctl_pipe[1];
+  fsrv_st_fd  = st_pipe[0];
+
+  /* Configure timeout, wait for child, cancel timeout. */
+
+  if (exec_tmout) {
+
+    child_timed_out = 0;
+    it.it_value.tv_sec = (exec_tmout * FORK_WAIT_MULT / 1000);
+    it.it_value.tv_usec = ((exec_tmout * FORK_WAIT_MULT) % 1000) * 1000;
+
+  }
+
+  setitimer(ITIMER_REAL, &it, NULL);
+
+  rlen = read(fsrv_st_fd, &status, 4);
+
+  it.it_value.tv_sec = 0;
+  it.it_value.tv_usec = 0;
+  setitimer(ITIMER_REAL, &it, NULL);
+
+  if(!quiet_mode)
+    SAYF(cRST "-- Program output ends --\n");
+
+  /* If we have a four-byte "hello" message from the server, we're all set.
+     Otherwise, try to figure out what went wrong. */
+
+  if (rlen == 4) {
+    if(!quiet_mode)
+      SAYF("All right - fork server is up.");
+    return;
+  }
+
+  if (waitpid(forksrv_pid, &status, 0) <= 0)
+    PFATAL("waitpid() failed");
+
+  if (WIFSIGNALED(status))
+    child_crashed = 1;
+
+  if (!quiet_mode) {
+
+    if (child_timed_out)
+      SAYF(cLRD "\n+++ Program timed off +++\n" cRST);
+    else if (stop_soon)
+      SAYF(cLRD "\n+++ Program aborted by user +++\n" cRST);
+    else if (child_crashed)
+      SAYF(cLRD "\n+++ Program killed by signal %u +++\n" cRST, WTERMSIG(status));
+
+  }
+
+}
+
+
+/* Execute target application. */
+
+static u8 run_target(char** argv) {
+
+  static struct itimerval it;
+  static u32 prev_timed_out = 0;
+
+  int status = 0;
+
+  if(!quiet_mode)
+    SAYF("-- Program output begins --\n" cRST);
+
+  /* After this memset, trace_bits[] are effectively volatile, so we
+     must prevent any earlier operations from venturing into that
+     territory. */
+
+  memset(trace_bits, 0, MAP_SIZE);
+  MEM_BARRIER();
+
+  s32 res;
+
+  /* we have the fork server up and running, so simply
+     tell it to have at it, and then read back PID. */
+
+  if ((res = write(fsrv_ctl_fd, &prev_timed_out, 4)) != 4) {
+
+    if (stop_soon) return 0;
+    RPFATAL(res, "Unable to request new process from fork server (OOM?)");
+
+  }
+
+  if ((res = read(fsrv_st_fd, &child_pid, 4)) != 4) {
+
+    if (stop_soon) return 0;
+    RPFATAL(res, "Unable to request new process from fork server (OOM?)");
+
+  }
+
+  if (child_pid <= 0) FATAL("Fork server is misbehaving (OOM?)");
+
+
   /* Configure timeout, wait for child, cancel timeout. */
 
   if (exec_tmout) {
@@ -314,13 +440,21 @@ static void run_target(char** argv) {
 
   setitimer(ITIMER_REAL, &it, NULL);
 
-  if (waitpid(child_pid, &status, 0) <= 0) FATAL("waitpid() failed");
+  if ((res = read(fsrv_st_fd, &status, 4)) != 4) {
+
+    if (stop_soon) return 0;
+    RPFATAL(res, "Unable to communicate with fork server (OOM?)");
+
+  }
 
   child_pid = 0;
   it.it_value.tv_sec = 0;
   it.it_value.tv_usec = 0;
   setitimer(ITIMER_REAL, &it, NULL);
 
+  if(!quiet_mode)
+    SAYF(cRST "-- Program output ends --\n");
+
   MEM_BARRIER();
 
   /* Clean up bitmap, analyze exit condition, etc. */
@@ -331,8 +465,7 @@ static void run_target(char** argv) {
   classify_counts(trace_bits, binary_mode ?
                   count_class_binary : count_class_human);
 
-  if (!quiet_mode)
-    SAYF(cRST "-- Program output ends --\n");
+  prev_timed_out = child_timed_out;
 
   if (!child_timed_out && !stop_soon && WIFSIGNALED(status))
     child_crashed = 1;
@@ -348,7 +481,7 @@ static void run_target(char** argv) {
 
   }
 
-
+  return 0;
 }
 
 
@@ -410,6 +543,9 @@ static void setup_signal_handlers(void) {
   sa.sa_handler = handle_timeout;
   sigaction(SIGALRM, &sa, NULL);
 
+  /* ignore */
+  sigaction(SIGPIPE, &sa, NULL);
+
 }
 
 
@@ -471,11 +607,12 @@ static void usage(u8* argv0) {
 
   show_banner();
 
-  SAYF("\n%s [ options ] -- /path/to/target_app [ ... ]\n\n"
+  SAYF("\n%s [ options ] -- /path/to/target_app [ ... ]\n"
+       "%s [ options ] files.. -- /path/to/target_app [ ... ]\n\n"
 
        "Required parameters:\n\n"
 
-       "  -o file       - file to write the trace data to\n\n"
+       "  -o file       - file (or dir) to write the trace data to\n\n"
 
        "Execution control settings:\n\n"
 
@@ -492,7 +629,7 @@ static void usage(u8* argv0) {
        "This tool displays raw tuple data captured by AFL instrumentation.\n"
        "For additional help, consult %s/README.\n\n" cRST,
 
-       argv0, MEM_LIMIT, doc_path);
+       argv0, argv0, MEM_LIMIT, doc_path);
 
   exit(1);
 
@@ -554,7 +691,8 @@ static void find_binary(u8* fname) {
 
 /* Fix up argv for QEMU. */
 
-static char** get_qemu_argv(u8* own_loc, char** argv, int argc) {
+static char** get_qemu_argv(int qemu_mode, u8* own_loc, char** argv, int argc) {
+
 
   char** new_argv = ck_alloc(sizeof(char*) * (argc + 4));
   u8 *tmp, *cp, *rsl, *own_copy;
@@ -563,10 +701,13 @@ static char** get_qemu_argv(u8* own_loc, char** argv, int argc) {
 
   setenv("QEMU_LOG", "nochain", 1);
 
-  memcpy(new_argv + 3, argv + 1, sizeof(char*) * argc);
-
-  new_argv[2] = target_path;
-  new_argv[1] = "--";
+  if(qemu_mode == 1) {
+    memcpy(new_argv + 3, argv + 1, sizeof(char*) * argc);
+    new_argv[2] = target_path;
+    new_argv[1] = "--";
+  } else {
+    memcpy(new_argv + 1, argv + 1, sizeof(char*) * argc);
+  } 
 
   /* Now we need to actually find qemu for argv[0]. */
 
@@ -574,7 +715,10 @@ static char** get_qemu_argv(u8* own_loc, char** argv, int argc) {
 
   if (tmp) {
 
-    cp = alloc_printf("%s/afl-qemu-trace", tmp);
+    if(qemu_mode == 1)
+      cp = alloc_printf("%s/afl-qemu-trace", tmp);
+    else
+      cp = alloc_printf("%s/afl-qemu-system-trace", tmp);
 
     if (access(cp, X_OK))
       FATAL("Unable to find '%s'", tmp);
@@ -591,7 +735,10 @@ static char** get_qemu_argv(u8* own_loc, char** argv, int argc) {
 
     *rsl = 0;
 
-    cp = alloc_printf("%s/afl-qemu-trace", own_copy);
+    if(qemu_mode == 1)
+      cp = alloc_printf("%s/afl-qemu-trace", own_copy);
+    else
+      cp = alloc_printf("%s/afl-qemu-system-trace", own_copy);
     ck_free(own_copy);
 
     if (!access(cp, X_OK)) {
@@ -603,10 +750,15 @@ static char** get_qemu_argv(u8* own_loc, char** argv, int argc) {
 
   } else ck_free(own_copy);
 
-  if (!access(BIN_PATH "/afl-qemu-trace", X_OK)) {
+  if (qemu_mode == 1 && !access(BIN_PATH "/afl-qemu-trace", X_OK)) {
 
     target_path = new_argv[0] = BIN_PATH "/afl-qemu-trace";
     return new_argv;
+  }
+  if (qemu_mode > 1 && !access(BIN_PATH "/afl-qemu-system-trace", X_OK)) {
+
+    target_path = new_argv[0] = BIN_PATH "/afl-qemu-system-trace";
+    return new_argv;
 
   }
 
@@ -622,9 +774,23 @@ int main(int argc, char** argv) {
   s32 opt;
   u8  mem_limit_given = 0, timeout_given = 0, qemu_mode = 0;
   u32 tcnt;
-  char** use_argv;
+  char** use_argv, **argv2, **files;
+  int argc2, i, nfiles;
+
 
   doc_path = access(DOC_PATH, F_OK) ? "docs" : DOC_PATH;
+ 
+  /* split command line */
+  for(i = 1; i < argc; i++) {
+    if(strcmp(argv[i], "--") == 0)
+      break;
+  }
+  if(!argv[i])
+    usage(argv[0]);
+  argv[i] = 0;
+  argv2 = argv + (i + 1);
+  argc2 = argc - (i + 1);
+  argc = i;
 
   while ((opt = getopt(argc,argv,"+o:m:t:A:eqZQbc")) > 0)
 
@@ -717,10 +883,10 @@ int main(int argc, char** argv) {
 
       case 'Q':
 
-        if (qemu_mode) FATAL("Multiple -Q options not supported");
+        //if (qemu_mode) FATAL("Multiple -Q options not supported");
         if (!mem_limit_given) mem_limit = MEM_LIMIT_QEMU;
 
-        qemu_mode = 1;
+        qemu_mode += 1;
         break;
 
       case 'b':
@@ -743,36 +909,62 @@ int main(int argc, char** argv) {
 
     }
 
-  if (optind == argc || !out_file) usage(argv[0]);
+  files = argv + optind;
+  nfiles = argc - optind;
+
+  if (!out_file || !argc2) usage(argv[0]);
+  if (files[0] && at_file) FATAL("Multi-file and -A option are incompatible");
 
   setup_shm();
   setup_signal_handlers();
 
   set_up_environment();
 
-  find_binary(argv[optind]);
+  find_binary(argv2[0]);
+
 
   if (!quiet_mode) {
     show_banner();
     ACTF("Executing '%s'...\n", target_path);
   }
 
-  detect_file_args(argv + optind);
+  if(files[0])
+    at_file = ".curinput"; // XXX shared by everyone in cwd!
+  detect_file_args(argv2);
 
   if (qemu_mode)
-    use_argv = get_qemu_argv(argv[0], argv + optind, argc - optind);
+    use_argv = get_qemu_argv(qemu_mode, argv[0], argv2, argc2);
   else
-    use_argv = argv + optind;
+    use_argv = argv2;
 
-  run_target(use_argv);
+  init_forkserver(use_argv);
+  if(!files[0]) { /* just run cmd, output to file */
+    run_target(use_argv);
+    tcnt = write_results();
 
-  tcnt = write_results();
-
-  if (!quiet_mode) {
-
-    if (!tcnt) FATAL("No instrumentation detected" cRST);
-    OKF("Captured %u tuples in '%s'." cRST, tcnt, out_file);
+    if (!quiet_mode) {
+      if (!tcnt) FATAL("No instrumentation detected" cRST);
+      OKF("Captured %u tuples in '%s'." cRST, tcnt, out_file);
+    }
 
+  } else {        /* run all files, output to dir */
+    char *out_dir = out_file;
+    mkdir(out_dir, 0755);
+    for(i = 0; i < nfiles; i++) {
+      SAYF("file %d/%d - %s\n", i+1, nfiles, files[i]);
+      unlink(at_file);
+      if(symlink(files[i], at_file) == -1)
+        FATAL("symlink %s to %s failed", files[i], at_file);
+
+      run_target(use_argv);
+
+      out_file = alloc_printf("%s/%s", out_dir, basename(files[i]));
+      tcnt = write_results();
+      if (!quiet_mode) {
+        if (!tcnt) FATAL("No instrumentation detected" cRST);
+        OKF("Captured %u tuples in '%s'." cRST, tcnt, out_file);
+      }
+    }
   }
 
   exit(child_crashed * 2 + child_timed_out);
diff --git a/afl-tmin.c b/afl-tmin.c
index a58c520..96cbe31 100644
--- a/afl-tmin.c
+++ b/afl-tmin.c
@@ -44,7 +44,11 @@
 #include <sys/types.h>
 #include <sys/resource.h>
 
-static s32 child_pid;                 /* PID of the tested program         */
+static s32 forksrv_pid,               /* PID of the fork server           */
+           child_pid;                 /* PID of the tested program        */
+
+static s32 fsrv_ctl_fd,               /* Fork server control pipe (write) */
+           fsrv_st_fd;                /* Fork server status pipe (read)   */
 
 static u8 *trace_bits,                /* SHM with instrumentation bitmap   */
           *mask_bitmap;               /* Mask for trace bits (-B)          */
@@ -55,8 +59,12 @@ static u8 *in_file,                   /* Minimizer input test case         */
           *target_path,               /* Path to target binary             */
           *doc_path;                  /* Path to docs                      */
 
+static s32 prog_in_fd;                /* Persistent fd for prog_in         */
+
 static u8* in_data;                   /* Input data for trimming           */
 
+static u8 qemu_mode = 0;              /* Running in QEMU mode?             */
+
 static u32 in_len,                    /* Input data length                 */
            orig_cksum,                /* Original checksum                 */
            total_execs,               /* Total number of execs             */
@@ -236,38 +244,71 @@ static s32 write_to_file(u8* path, u8* mem, u32 len) {
 
 }
 
+/* Write modified data to file for testing. If use_stdin is clear, the old file
+   is unlinked and a new one is created. Otherwise, prog_in_fd is rewound and
+   truncated. */
+
+static void write_to_testcase(void* mem, u32 len) {
+
+  s32 fd = prog_in_fd;
+
+  if (!use_stdin) {
+
+    unlink(prog_in); /* Ignore errors. */
+
+    fd = open(prog_in, O_WRONLY | O_CREAT | O_EXCL, 0600);
+
+    if (fd < 0) PFATAL("Unable to create '%s'", prog_in);
+
+  } else lseek(fd, 0, SEEK_SET);
+
+  ck_write(fd, mem, len, prog_in);
+
+  if (use_stdin) {
+
+    if (ftruncate(fd, len)) PFATAL("ftruncate() failed");
+    lseek(fd, 0, SEEK_SET);
+
+  } else close(fd);
+
+}
+
+
 
 /* Handle timeout signal. */
 
 static void handle_timeout(int sig) {
 
-  child_timed_out = 1;
-  if (child_pid > 0) kill(child_pid, SIGKILL);
+  if (child_pid > 0) {
 
-}
+    child_timed_out = 1;
+    kill(child_pid, SIGKILL);
 
+  } else if (child_pid == -1 && forksrv_pid > 0) {
 
-/* Execute target application. Returns 0 if the changes are a dud, or
-   1 if they should be kept. */
+    child_timed_out = 1;
+    kill(forksrv_pid, SIGKILL);
 
-static u8 run_target(char** argv, u8* mem, u32 len, u8 first_run) {
+  }
 
-  static struct itimerval it;
-  int status = 0;
+}
 
-  s32 prog_in_fd;
-  u32 cksum;
 
-  memset(trace_bits, 0, MAP_SIZE);
-  MEM_BARRIER();
+/* start the app and it's forkserver */
+static void init_forkserver(char **argv) {
+  static struct itimerval it;
+  int st_pipe[2], ctl_pipe[2];
+  int status = 0;
+  s32 rlen;
 
-  prog_in_fd = write_to_file(prog_in, mem, len);
+  ACTF("Spinning up the fork server...");
+  if (pipe(st_pipe) || pipe(ctl_pipe)) PFATAL("pipe() failed");
 
-  child_pid = fork();
+  forksrv_pid = fork();
 
-  if (child_pid < 0) PFATAL("fork() failed");
+  if (forksrv_pid< 0) PFATAL("fork() failed");
 
-  if (!child_pid) {
+  if (!forksrv_pid) {
 
     struct rlimit r;
 
@@ -303,6 +344,16 @@ static u8 run_target(char** argv, u8* mem, u32 len, u8 first_run) {
 
     r.rlim_max = r.rlim_cur = 0;
     setrlimit(RLIMIT_CORE, &r); /* Ignore errors */
+ 
+    /* Set up control and status pipes, close the unneeded original fds. */
+
+    if (dup2(ctl_pipe[0], FORKSRV_FD) < 0) PFATAL("dup2() failed");
+    if (dup2(st_pipe[1], FORKSRV_FD + 1) < 0) PFATAL("dup2() failed");
+
+    close(ctl_pipe[0]);
+    close(ctl_pipe[1]);
+    close(st_pipe[0]);
+    close(st_pipe[1]);
 
     execv(target_path, argv);
 
@@ -311,22 +362,115 @@ static u8 run_target(char** argv, u8* mem, u32 len, u8 first_run) {
 
   }
 
-  close(prog_in_fd);
+  /* Close the unneeded endpoints. */
+
+  close(ctl_pipe[0]);
+  close(st_pipe[1]);
+
+  fsrv_ctl_fd = ctl_pipe[1];
+  fsrv_st_fd  = st_pipe[0];
+
+  /* Configure timeout, wait for child, cancel timeout. */
+  if (exec_tmout) {
+
+    child_timed_out = 0;
+    it.it_value.tv_sec = (exec_tmout * FORK_WAIT_MULT / 1000);
+    it.it_value.tv_usec = ((exec_tmout * FORK_WAIT_MULT) % 1000) * 1000;
+
+  }
+
+  setitimer(ITIMER_REAL, &it, NULL);
+  rlen = read(fsrv_st_fd, &status, 4);
+
+  it.it_value.tv_sec = 0;
+  it.it_value.tv_usec = 0;
+  setitimer(ITIMER_REAL, &it, NULL);
+
+  /* If we have a four-byte "hello" message from the server, we're all set.
+     Otherwise, try to figure out what went wrong. */
+
+  if (rlen == 4) {
+    ACTF("All right - fork server is up.");
+    return;
+  }
+
+  if (waitpid(forksrv_pid, &status, 0) <= 0)
+    PFATAL("waitpid() failed");
+
+  u8 child_crashed;
+
+  if (WIFSIGNALED(status))
+    child_crashed = 1;
+
+  if (child_timed_out)
+    SAYF(cLRD "\n+++ Program timed off +++\n" cRST);
+  else if (stop_soon)
+    SAYF(cLRD "\n+++ Program aborted by user +++\n" cRST);
+  else if (child_crashed)
+    SAYF(cLRD "\n+++ Program killed by signal %u +++\n" cRST, WTERMSIG(status));
+
+}
+
+static u8 run_target(char** argv, u8* mem, u32 len, u8 first_run) {
+
+  static struct itimerval it;
+  static u32 prev_timed_out = 0;
+  int status = 0;
+
+  u32 cksum;
+
+  memset(trace_bits, 0, MAP_SIZE);
+  MEM_BARRIER();
+
+  write_to_testcase(mem, len);
+
+  s32 res;
+
+  /* we have the fork server up and running, so simply
+     tell it to have at it, and then read back PID. */
+
+  if ((res = write(fsrv_ctl_fd, &prev_timed_out, 4)) != 4) {
+
+    if (stop_soon) return 0;
+    RPFATAL(res, "Unable to request new process from fork server (OOM?)");
+
+  }
+
+  if ((res = read(fsrv_st_fd, &child_pid, 4)) != 4) {
+
+    if (stop_soon) return 0;
+    RPFATAL(res, "Unable to request new process from fork server (OOM?)");
+
+  }
+
+  if (child_pid <= 0) FATAL("Fork server is misbehaving (OOM?)");
 
   /* Configure timeout, wait for child, cancel timeout. */
 
-  child_timed_out = 0;
-  it.it_value.tv_sec = (exec_tmout / 1000);
-  it.it_value.tv_usec = (exec_tmout % 1000) * 1000;
+  if (exec_tmout) {
+
+    child_timed_out = 0;
+    it.it_value.tv_sec = (exec_tmout / 1000);
+    it.it_value.tv_usec = (exec_tmout % 1000) * 1000;
+
+  }
 
   setitimer(ITIMER_REAL, &it, NULL);
 
-  if (waitpid(child_pid, &status, 0) <= 0) FATAL("waitpid() failed");
+  if ((res = read(fsrv_st_fd, &status, 4)) != 4) {
+
+    if (stop_soon) return 0;
+    RPFATAL(res, "Unable to communicate with fork server (OOM?)");
+
+  }
 
   child_pid = 0;
   it.it_value.tv_sec = 0;
   it.it_value.tv_usec = 0;
 
+/* Execute target application. Returns 0 if the changes are a dud, or
+   1 if they should be kept. */
+
   setitimer(ITIMER_REAL, &it, NULL);
 
   MEM_BARRIER();
@@ -342,7 +486,7 @@ static u8 run_target(char** argv, u8* mem, u32 len, u8 first_run) {
 
   if (stop_soon) {
 
-    SAYF(cRST cLRD "\n+++ Minimization aborted by user +++\n" cRST);
+    ACTF(cRST cLRD "\n+++ Minimization aborted by user +++\n" cRST);
     close(write_to_file(out_file, in_data, in_len));
     exit(1);
 
@@ -359,9 +503,20 @@ static u8 run_target(char** argv, u8* mem, u32 len, u8 first_run) {
 
   /* Handle crashing inputs depending on current mode. */
 
+  int crashed = 0;
+
   if (WIFSIGNALED(status) ||
       (WIFEXITED(status) && WEXITSTATUS(status) == MSAN_ERROR) ||
       (WIFEXITED(status) && WEXITSTATUS(status) && exit_crash)) {
+        crashed = 1;
+      }
+
+  /* treat all non-zero return values from qemu system test as a crash */
+  if(qemu_mode > 1 && WEXITSTATUS(status) != 0) {
+    crashed = 1;
+  }
+
+  if (crashed) {
 
     if (first_run) crash_mode = 1;
 
@@ -687,6 +842,13 @@ static void set_up_environment(void) {
 
   }
 
+  unlink(prog_in);
+
+  prog_in_fd = open(prog_in, O_RDWR | O_CREAT | O_EXCL, 0600);
+
+  if (prog_in_fd < 0) PFATAL("Unable to create '%s'", prog_in);
+
+
   /* Set sane defaults... */
 
   x = getenv("ASAN_OPTIONS");
@@ -889,7 +1051,7 @@ static void find_binary(u8* fname) {
 
 /* Fix up argv for QEMU. */
 
-static char** get_qemu_argv(u8* own_loc, char** argv, int argc) {
+static char** get_qemu_argv(int qemu_mode, u8* own_loc, char** argv, int argc) {
 
   char** new_argv = ck_alloc(sizeof(char*) * (argc + 4));
   u8 *tmp, *cp, *rsl, *own_copy;
@@ -898,18 +1060,27 @@ static char** get_qemu_argv(u8* own_loc, char** argv, int argc) {
 
   setenv("QEMU_LOG", "nochain", 1);
 
-  memcpy(new_argv + 3, argv + 1, sizeof(char*) * argc);
-
+  if(qemu_mode == 1) {
+    memcpy(new_argv + 3, argv + 1, sizeof(char*) * argc);
+ 
+    new_argv[2] = target_path;
+    new_argv[1] = "--";
+  } else {
+    memcpy(new_argv + 1, argv + 1, sizeof(char*) * argc);
+  }
+ 
   /* Now we need to actually find qemu for argv[0]. */
+   tmp = getenv("AFL_PATH");
 
-  new_argv[2] = target_path;
-  new_argv[1] = "--";
 
   tmp = getenv("AFL_PATH");
 
   if (tmp) {
 
-    cp = alloc_printf("%s/afl-qemu-trace", tmp);
+    if(qemu_mode == 1)
+      cp = alloc_printf("%s/afl-qemu-trace", tmp);
+    else
+      cp = alloc_printf("%s/afl-qemu-system-trace", tmp);
 
     if (access(cp, X_OK))
       FATAL("Unable to find '%s'", tmp);
@@ -926,7 +1097,10 @@ static char** get_qemu_argv(u8* own_loc, char** argv, int argc) {
 
     *rsl = 0;
 
-    cp = alloc_printf("%s/afl-qemu-trace", own_copy);
+    if(qemu_mode == 1)
+      cp = alloc_printf("%s/afl-qemu-trace", own_copy);
+    else
+      cp = alloc_printf("%s/afl-qemu-system-trace", own_copy);
     ck_free(own_copy);
 
     if (!access(cp, X_OK)) {
@@ -938,11 +1112,17 @@ static char** get_qemu_argv(u8* own_loc, char** argv, int argc) {
 
   } else ck_free(own_copy);
 
-  if (!access(BIN_PATH "/afl-qemu-trace", X_OK)) {
+  if (qemu_mode == 1 && !access(BIN_PATH "/afl-qemu-trace", X_OK)) {
 
     target_path = new_argv[0] = BIN_PATH "/afl-qemu-trace";
     return new_argv;
 
+  }
+  if (qemu_mode > 1 && !access(BIN_PATH "/afl-qemu-system-trace", X_OK)) {
+
+    target_path = new_argv[0] = BIN_PATH "/afl-qemu-system-trace";
+    return new_argv;
+
   }
 
   FATAL("Unable to find 'afl-qemu-trace'.");
@@ -971,7 +1151,7 @@ static void read_bitmap(u8* fname) {
 int main(int argc, char** argv) {
 
   s32 opt;
-  u8  mem_limit_given = 0, timeout_given = 0, qemu_mode = 0;
+  u8  mem_limit_given = 0, timeout_given = 0;
   char** use_argv;
 
   doc_path = access(DOC_PATH, F_OK) ? "docs" : DOC_PATH;
@@ -1064,10 +1244,10 @@ int main(int argc, char** argv) {
 
       case 'Q':
 
-        if (qemu_mode) FATAL("Multiple -Q options not supported");
+        //if (qemu_mode) FATAL("Multiple -Q options not supported");
         if (!mem_limit_given) mem_limit = MEM_LIMIT_QEMU;
 
-        qemu_mode = 1;
+        qemu_mode += 1;
         break;
 
       case 'B': /* load bitmap */
@@ -1107,7 +1287,7 @@ int main(int argc, char** argv) {
   detect_file_args(argv + optind);
 
   if (qemu_mode)
-    use_argv = get_qemu_argv(argv[0], argv + optind, argc - optind);
+    use_argv = get_qemu_argv(qemu_mode, argv[0], argv + optind, argc - optind);
   else
     use_argv = argv + optind;
 
@@ -1117,6 +1297,8 @@ int main(int argc, char** argv) {
 
   read_initial_file();
 
+  init_forkserver(use_argv);
+
   ACTF("Performing dry run (mem limit = %llu MB, timeout = %u ms%s)...",
        mem_limit, exec_tmout, edges_only ? ", edges only" : "");
 
diff --git a/config.h b/config.h
index e74b3b3..5e4457a 100644
--- a/config.h
+++ b/config.h
@@ -57,7 +57,7 @@
 
 /* Default memory limit when running in QEMU mode (MB): */
 
-#define MEM_LIMIT_QEMU      200
+#define MEM_LIMIT_QEMU      2048
 
 /* Number of calibration cycles per every new test case (and for test
    cases that show variable behavior): */
@@ -294,7 +294,7 @@
 /* Fork server init timeout multiplier: we'll wait the user-selected
    timeout plus this much for the fork server to spin up. */
 
-#define FORK_WAIT_MULT      10
+#define FORK_WAIT_MULT      100000
 
 /* Calibration timeout adjustments, to be a bit more generous when resuming
    fuzzing sessions or trying to calibrate already-added internal finds.
@@ -313,7 +313,7 @@
    problems with complex programs). You need to recompile the target binary
    after changing this - otherwise, SEGVs may ensue. */
 
-#define MAP_SIZE_POW2       16
+#define MAP_SIZE_POW2       21
 #define MAP_SIZE            (1 << MAP_SIZE_POW2)
 
 /* Maximum allocator request size (keep well under INT_MAX): */
diff --git a/docs/README b/docs/README
index ac49599..d1b2e38 100644
--- a/docs/README
+++ b/docs/README
@@ -1,3 +1,122 @@
+<Project Fuzz Evaluation>
+This frontport was written to provide a fairer comparison of the "full" mode described in the paper
+"Firm-AFL: High-Throughput Greybox Fuzzing of IoT Firmware via Augmented Process Emulation".
+
+As FirmAFL brings its own (full-system-)qemu, this patchset *just* targets the frontend fuzzer, AFL.
+
+This patchset can be applied against AFL 2.52b (rather than 2.06b as used by the original TriForceAFL implementation).
+
+</Project Fuzz Evaluation>
+
+
+
+<ProjectTriforce>
+
+New: For those looking to play with TriforceAFL and TLSF, Richard Johnson created a Dockerfile which installs both (and even builds a Linux kernel for you). It's available here <https://hub.docker.com/r/moflow/afl-triforce/tags/>.
+
+Also new: afl-tmin now works with the forkserver!
+
+
+https://github.com/nccgroup/TriforceAFL
+Jesse Hertz <jesse.hertz@nccgroup.trust>
+Tim Newsham <tim.newsham@nccgroup.trust>
+
+This is a patched version of AFL that supports full-system
+fuzzing using QEMU. The included QEMU has been updated to allow tracing
+of branches when running a system emulator for x86_64.
+Extra instructions have been added to start AFL's forkserver,
+make fuzz settings, and mark the start and stop of test cases.
+
+Note: not all of the AFL tools have been tested with the
+new changes.  These tools have seen some testing:
+
+   - afl-fuzz - patched to support -QQ 
+   - afl-showmap - patched to support -QQ and forkserver (with batching)
+   - afl-cmin - patched to support -QQ and use forkserver, 
+                stdin no longer supported
+   - afl-analyze - patched to support -QQ
+   - afl-tmin - patched to support -QQ,  but does not support forkserver!
+
+---
+To build:
+
+  make
+
+---
+To get a coverage map:
+
+  echo hello > /tmp/hello
+  ./afl-showmap -o coverage.txt -QQ -- \
+      ./afl-qemu-system-trace -kernel ../bzImage \
+      -initrd ../initramfs.cpio.gz -m 1G -nographic \
+      -append "console=ttyS0" -aflFile /tmp/hello
+  cat coverage.txt
+
+---
+To fuzz:
+
+  # figure out what addrs to use below...
+  egrep ' (panic|log_store)$' ../mykern/kallsyms
+    ffffffff8108e570 t log_store
+    ffffffff8181064b T panic
+
+  mkdir inputs
+  echo hello > inputs/hello
+  ./afl-fuzz -i inputs -o outputs -QQ -- \
+        afl-qemu-system-trace -kernel bzImage -initrd root.cpio.gz \
+        -m 1G -nographic -append "console=ttyS0" \
+        -aflPanicAddr ffffffff8181064b -aflDmesgAddr ffffffff8108e570 \
+        -aflFile @@
+
+(Note: unlike when using the "-Q" option, you must specify the
+full command line to afl-qemu-system-trace when using the "-QQ" option).
+
+For more details on how to use this modified version of AFL,
+see our Linux syscall fuzzer at 
+https://github.com/nccgroup/TriforceLinuxSyscallFuzzer.
+  
+---
+New AFL flags:
+   -QQ  - use qemu in full-system emulation rather than user-mode (-Q)
+
+New QEMU flags:
+   -aflFile - The name of the file containing fuzzer inputs
+   -aflPanicAddr - A address of a kernel panic address for panic detection
+   -aflDmesgAddr - Linux kernel address of dmesg logging function for
+                   detecting logging and intercepting log messages
+
+New QEMU instructions:
+   0f 24 - aflCall
+      edi=1 startForkserver(esi=enableTicks)
+            Start AFL's fork server.  After this point each test
+            will run in a separate forked child.  If enableTicks is
+            non-zero, QEMU will re-enable the CPUs timer after
+            forking a child, otherwise it will not be enabled.
+      edi=2 getWork(esi=ptr, edx=sz)
+            Fill ptr[0..sz] with the next input test case. Returns
+            the actual size filled (<= sz).
+      edi=3 startWork(esi=ptr)
+            Tell AFL to start tracing.  The argument points to a
+            buffer with two quadwords giving the start and end
+            address of the code to trace.  Instructions outside
+            of this range are not traced.
+      edi=4 doneWork(esi=exitCode)
+            Tell AFL that the test case has completed.  If a panic
+            is detected, AFL will stop the test case immediately.
+            Otherwise it will run until doneWork is called.
+            The exitCode specified is returned to AFL.  (The
+            code can, but currently does not, OR in the value 64
+            to all exit codes if any dmesg logs were detected during
+            the test case.)
+
+New QEMU block driver:
+   -drive filename=privmem:<name> 
+      This block driver keeps the drive's image in copy-on-write memory
+      so that changes are never persisted to disk.  Changes made by
+      on test case are isolated from other test cases.
+
+</ProjectTriforce>
+
 ==================
 american fuzzy lop
 ==================
